#include <cv.hpp>
#include <opencv2/highgui/highgui.hpp>
#include "caliberate.h"	
#include <iostream>
#include <ctime>				
#include <cmath>


using namespace std;
using namespace cv;
VideoCapture capture;		//The capture class captures video either from harddisk(.avi) or from camera
Mat frameImg;				
Mat g_image;				

double dist(Point2i x1, Point2i x2)	
{	
	return sqrt( pow((x1.x-x2.x),2) + pow((x1.y-x2.y),2) ); 
}

int main() 
{
	string fileName = "traffic.avi";
	capture.open(fileName);		
	if( !capture.isOpened() )
	{	
		cerr<<"video opening error\n"; waitKey(0); system("pause");  
	}

	Mat frameImg_origSize;							//image taken from camera feed in original size
	namedWindow( "out"	  , CV_WINDOW_AUTOSIZE);	//window to show output
	namedWindow( "trackbar", CV_WINDOW_AUTOSIZE);	//Trackbars to change value of parameters
	resizeWindow( "trackbar", 300, 600);			//Resizing trackbar window for proper view of all the parameters
	
	capture>>frameImg_origSize;
	if( frameImg_origSize.empty() ) { cout<<"something wrong"; }
	
	resize(frameImg_origSize, frameImg, SMALL_SIZE, 0, 0, CV_INTER_AREA);	//Resize original frame into smaller frame for faster calculations

	g_image = Mat(SMALL_SIZE, CV_8UC1);	g_image.setTo(0);	//Gray image of frameImg
	
	Mat roadImage = Mat(SMALL_SIZE, CV_8UC3);	//Image of the road (without vehicles)
	roadImage = findRoadImage();
	
	calibPolygon();	//Polygon caliberation: Select four points of polygon (ROI) clockwise and press enter

	Mat binImage = Mat(SMALL_SIZE,CV_8UC1);	//white pixel = cars, black pixel = other than cars
	Mat finalImage = Mat(SMALL_SIZE, CV_8UC3);	//final image to show output

	time_t T = time(0);	//Current time
	float fps = 0, lastCount = 0;	//frames per second

	int thresh_r = 43, thresh_g = 43, thresh_b = 49;						//Threshold parameters for Red, Green, Blue colors
	createTrackbar( "Red Threshold", "trackbar", &thresh_r, 255, 0 );		//Threshold for Red color
	createTrackbar( "Green Threshold", "trackbar", &thresh_g, 255, 0 );		//Threshold for Green color
	createTrackbar( "Blue Threshold", "trackbar", &thresh_b, 255, 0 );		//Threshold for Blue color

	int dilate1=1, erode1=2, dilate2=5;	//Dilate and Erode parameters
	Mat imgA = Mat(SMALL_SIZE, CV_8SC3);	//Used for opticalFlow
	int win_size = 20;	//parameter for opticalFlow
	int corner_count = MAX_CORNERS;	//no of points tracked in opticalFlow
	vector<Point2i> cornersA, cornersB;

	frameImg.copyTo(imgA);

	int arrowGap = 5;	//distance between consecutive tracking points (opticalFlow)
	
	createTrackbar("dilate 1","trackbar", &dilate1, 15, 0);	
	createTrackbar("erode 1","trackbar", &erode1, 15, 0);	
	createTrackbar("dilate 2","trackbar", &dilate2, 15, 0);	
	
	//TODO make callback function for dilate and erode and update their element matrixes
	Mat dilate1_element = getStructuringElement(MORPH_ELLIPSE , Size(2 * dilate1 + 1, 2 * dilate1 + 1), Point(-1,-1) );
	Mat erode1_element = getStructuringElement(MORPH_ELLIPSE , Size(2 * erode1 + 1, 2 * erode1 + 1), Point(-1,-1) );
	Mat dilate2_element = getStructuringElement(MORPH_ELLIPSE , Size(2 * dilate2 + 1, 2 * dilate2 + 1), Point(-1,-1) );
	
	vector< Vec4i > hierarchy;
	vector< vector<Point> > contours;
	vector< uchar > vstatus; 
	vector< float >verror;

	
